# **'관심 프로젝트' 기능 백엔드 구현**

## 📚 목차

1. [초기 문제 상황](#1_기능_개요)
2. [데이터 모델-entity](#2_데이터_모델_entity)
3. [데이터 접근 계층-repository](#3_데이터_접근_계층-repository)
4. [서비스 계층-business logic](#4_서비스_계층-business_logic)
5. [api 계층-controller](#5_api_계층-controller)
6. [다른 서비스와의 연동 및 활용](#6_다른_서비스와의_연동_및_활용)

---

## **1. 기능 개요**

'관심 프로젝트'는 사용자가 흥미로운 프로젝트를 저장(찜하기)하고, 나중에 쉽게 찾아볼 수 있도록 하는 기능이다. 핵심 기능은 다음과 같다.

- **관심 등록/해제 (Toggle):** 사용자는 버튼 클릭 한 번으로 특정 프로젝트를 관심 목록에 추가하거나 제거할 수 있다.
- **관심 목록 조회:** 사용자는 자신이 관심 등록한 모든 프로젝트의 목록을 조회할 수 있다.
- **상태 표시:** 프로젝트 목록을 볼 때, 각 프로젝트에 대해 현재 사용자의 관심 등록 여부(`isInterested`)가 함께 표시된다.

---

## **2. 데이터 모델 (Entity)**

사용자(`Profile`)와 프로젝트(`Project`) 간의 **다대다(Many-to-Many)** 관계를 표현하기 위해, `InterestProject`라는 별도의 조인 테이블 엔티티를 설계했다.

- **핵심 역할:** 어떤 `Profile`이 어떤 `Project`에 관심을 가졌는지 기록한다.
- **구조:** `profile_id`, `project_id`를 외래 키로 가지며, 두 ID의 조합이 하나의 관심 관계를 나타낸다.

```java
// InterestProject.java
package com.Gathering_be.domain;

import jakarta.persistence.*;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity
@NoArgsConstructor
@Getter
public class InterestProject {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profile_id", nullable = false)
    private Profile profile;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "project_id", nullable = false)
    private Project project;

    @Builder
    public InterestProject(Long id, Profile profile, Project project) {
        this.id = id;
        this.profile = profile;
        this.project = project;
    }
}
```

---

## **3. 데이터 접근 계층 (Repository)**

Spring Data JPA를 사용하여 데이터베이스와의 상호작용을 처리한다. `profileId`와 `projectId`를 조합하여 효율적으로 데이터를 조회, 확인, 삭제하는 쿼리 메서드를 정의했다.

- **주요 메서드:**
  - `existsByProfileIdAndProjectId(...)`: 특정 사용자가 특정 프로젝트에 이미 관심을 등록했는지 `boolean` 값으로 빠르게 확인한다. (토글 로직의 핵심)
  - `deleteByProfileIdAndProjectId(...)`: 특정 관심 등록 기록을 효율적으로 삭제한다.
  - `findAllByProfileId(...)`: 특정 사용자의 모든 관심 프로젝트 ID를 조회하여, 다른 서비스에서 `isInterested` 상태를 확인하는 데 사용된다.

```java
// InterestProjectRepository.java
package com.Gathering_be.repository;

import com.Gathering_be.domain.InterestProject;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.List;

public interface InterestProjectRepository extends JpaRepository<InterestProject, Long> {
    List<InterestProject> findByProfileNickname(String nickname);
    boolean existsByProfileIdAndProjectId(Long profileId, Long projectId);
    void deleteByProfileIdAndProjectId(Long profileId, Long projectId);
    List<InterestProject> findAllByProfileId(Long profileId);
}
```

---

## **4. 서비스 계층 (Business Logic)**

핵심 비즈니스 로직은 `InterestProjectService`에서 처리한다. 모든 메서드는 요청을 보낸 사용자가 해당 리소스에 접근할 권한이 있는지 `validateMemberAccess`를 통해 철저히 검증한다.

- **`toggleInterestProject` (관심 등록/해제):**
  1. `existsByProfileIdAndProjectId`를 통해 현재 관심 등록 상태를 확인한다.
  2. **만약 이미 존재한다면,** 새로운 `InterestProject` 엔티티를 생성하여 저장하고 `true`를 반환한다.
  3. 이 '토글(Toggle)' 방식을 통해 하나의 API로 두 가지 기능을 모두 처리하여 효율성을 높였다.
- **`getInterestProjects` (관심 목록 조회):**

  1. `findByProfileNickname`을 통해 특정 사용자의 모든 관심 프로젝트 목록을 조회하여 DTO로 변환 후 반환한다.

  ```java
  // InterestProjectService.java
  package com.Gathering_be.service;

  import com.Gathering_be.domain.InterestProject;
  // ... (기타 import)

  @Service
  @RequiredArgsConstructor
  public class InterestProjectService {
    private final ProfileRepository profileRepository;
    private final ProjectRepository projectRepository;
    private final InterestProjectRepository interestProjectRepository;

    @Transactional
    public boolean toggleInterestProject(InterestProjectRequest request) {
        // ... (로그인한 사용자 정보 및 권한 확인) ...

        boolean exists = interestProjectRepository
                                            .existsByProfileIdAndProjectId(profileId, projectId);

        if (exists) {
            interestProjectRepository
                .deleteByProfileIdAndProjectId(profileId, projectId);
            return false; // 관심 해제됨
        } else {
            InterestProject interestProject = InterestProject.builder()
                    .profile(profile)
                    .project(getProjectById(projectId))
                    .build();
            interestProjectRepository.save(interestProject);
            return true; // 관심 등록됨
        }
    }
    // ... (getInterestProjects 및 private 헬퍼 메서드) ...
  }


  ```

---

## **5. API 계층 (Controller)**

`InterestProjectController`는 외부 요청을 받아 `InterestProjectService`의 로직을 호출하는 창구 역할을 한다.

- **`POST /api/project/interest`:** `projectId`를 받아 `toggleInterestProject`서비스를 호출하고, 변경된 관심 상태(`true`/`false`)를 반환한다.
- **`GET /api/project/interest/{nickname}`:** `nickname`을 받아 `getInterestProjects` 서비스를 호출하고, 해당 사용자의 관심 프로젝트 목록을 반환한다.

```java
  // InterestProjectController.java
package com.Gathering_be.controller;

import com.Gathering_be.dto.request.InterestProjectRequest;
// ... (기타 import)

@RestController
@RequestMapping("/api/project/interest")
@RequiredArgsConstructor
public class InterestProjectController {
    private final InterestProjectService interestProjectService;

    @PostMapping
    public ResultResponse toggleInterestProject(@RequestBody InterestProjectRequest request) {
        boolean isInterest = interestProjectService.toggleInterestProject(request);
        return ResultResponse.of(ResultCode.INTEREST_PROJECT_TOGGLE_SUCCESS, isInterest);
    }

    @GetMapping("/{nickname}")
    public ResultResponse getInterestProjects(@PathVariable String nickname) {
        List<InterestProjectResponse> projects = interestProjectService.getInterestProjects(nickname);
        return ResultResponse.of(ResultCode.INTEREST_PROJECT_GET_SUCCESS, projects);
    }
}
```

---

## **6. 다른 서비스와의 연동 및 활용**

`ProjectService`나 `ApplicationService`와 같이, 프로젝트 목록을 사용자에게 보여줘야 하는 모든 곳에서는 `isInterested` 필드를 채워주기 위해 `InterestProjectRepository`를 직접 활용한다.

- **설계 결정:** 비즈니스 로직이 아닌 단순 조회를 위해 `InterestProjectService`를 거치지 않고, `InterestProjectRepository`를 직접 주입받아 사용함으로써 서비스 간의 불필요한 결합도를 낮추고 성능을 최적화했다.
- **구현 패턴:**

  1. 현재 로그인한 사용자의 `Profile ID`를 가져온다.
  2. `interestProjectRepository.findAllByProfileId()`를 호출하여 해당 사용자가 관심 등록한 모든 프로젝트의 ID를 Set<Long> 형태로 미리 준비한다.
  3. 사용자에게 보여줄 프로젝틑 목록을 순회하면서, 각 프로젝트의 ID가 위에서 만든 `Set`에 포함되어 있는지 확인하여 `isInterested` 값을 `true` 또는 `false`로 설정한다.

  ```java
  // ProjectService.java (활용 예시)
  public Page<ProjectSimpleResponse> searchProjectsWithFilters(...) {
      // ...
      // 1 & 2. 현재 사용자의 모든 관심 프로젝트 ID를 Set으로 미리 준비
      Set<Long> interestedProjectIds = interestProjectRepository.findAllByProfileId(...)
              .stream()
              .map(interest -> interest.getProject().getId())
              .collect(Collectors.toSet());

      // 3. 프로젝트 목록을 DTO로 변환할 때, Set에 포함되어 있는지 확인하여 isInterested 값 설정
      return projectPage
              .map(project -> ProjectSimpleResponse.from(project, interestedProjectIds.contains(project.getId()), null));
  }


  ```

---
