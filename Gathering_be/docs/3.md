# **계정 로그인 문제**

## 📚 목차

1. [로그인 방식 비대칭 동작 원인 분석](#1_로그인_방식_비대칭_동작_원인_분석)
2. [계정 통합(연결) 기능 구현](<#2_계정_통합(연결)_기능_구현>)

---

## **1. 로그인 방식 비대칭 동작 원인 분석**

### **시나리오 1: 자체 회원가입 → 구글 로그인 시도 (성공)**

**비정상적 상황**

- **동작 과정:**
  1. 사용자가 `cbk121779@gmail.com`으로 **자체 회원가입.**
  2. DB의 `member` 테이블에는 `email: "cbk121779@gmail.com"`, `provider: "BASIC"`인 사용자가 생성.
  3. 이후, 사용자가 **Google 로그인**을 시도.
  4. 프론트엔드는 Google로부터 받은 Access Token을 백엔드의 `AuthService.googleLogin()` 메서드로 전달.
  5. `googleLogin()` 메서드는 Access Token을 이용해 Google로부터 사용자 이메일(`cbk121779@gmail.com`)을 가져온다.
  6. **가장 중요한 부분:** `memberRepository.findByEmail("cbk121779@gmail.com")`를 호출합니다.
  7. 데이터베이스는 이메일이 일치하는 사용자를 성공적으로 찾아냄 (2번에서 만든 `BASIC` 사용자).
  8. `orElseGet(...)` (신규 사용자 생성 로직)은 실행되지 않고 건너뛴다.
  9. 코드는 찾아낸 기존 `Member` 객체를 사용하여 **JWT 토큰을 발급하고 로그인을 성공**시킨다.
- **핵심 원인:** `googleLogin` 메서드의 **애플리케이션 로직**이, 이메일로 사용자를 찾은 뒤 그 사용자의 기존 가입 방식(`provider`)이 `BASIC`인지 `GOOGLE`인지 **전혀 확인하지 않음**. 단순히 "이메일만 같으면 같은 사람"이라고 간주하고 로그인을 허용해 버린다.

---

### **시나리오 2: 구글 로그인 → 자체 회원가입 (실패)**

**정상적이고 올바른 동작**

- **동작 과정:**
  1. 사용자가 `cbk121779@gmail.com`으로 **Google 로그인**.
  2. `AuthService.googleLogin()`의 `orElseGet(...)` 부분이 실행되어, DB의 `member` 테이블에는 `email: "cbk121779@gmail.com"`, `provider: "GOOGLE"`인 사용자가 생성.
  3. 이후, 사용자가 같은 이메일로 **자체 회원가입**을 시도.
  4. 백엔드의 `AuthService.signup()` (또는 유사한) 메서드는 새로운 `Member` 객체를 만들어 `memberRepository.save()`를 호출.
  5. **가장 중요한 부분:** 데이터베이스(MySQL)는 새로운 데이터를 `member` 테이블에 `INSERT`하려고 시도.
  6. 이때, `Member` 엔티티에 정의된 **`@Column(nullable = false, unique = true)`** 라는

     **데이터베이스 제약 조건(Database Constraint)**이 작동.

  7. 데이터베이스는 "이미 `email` 컬럼에 `cbk121779@gmail.com` 값이 존재하므로, `unique` 제약 조건을 위반합니다" 라고 판단하여 **`INSERT` 작업을 거부하고 에러를 발생**.

     (보통 `DataIntegrityViolationException`)

  8. 이 에러로 인해 트랜잭션이 롤백되고, 최종적으로 "이미 가입된 이메일입니다" 라는 응답이 프론트엔드로 전달.
- **핵심 원인:** 이 시나리오는 애플리케이션 로직이 아니라, 더 근본적인 **데이터베이스의 규칙**에 의해 차단된다. `email`은 유일해야 한다는 DB의 제약 조건이 안전장치 역할을 수행한 것.

---

## **2. 계정 통합(연결) 기능 구현**

기존 `BASIC` 계정과 새로운 소셜 로그인 계정을 안전하게 연결하여, 계정 탈취 위험을 막고 사용자 경험을 향상시킨다.

### **새로운 사용자 경험(UX) 흐름**

1. 사용자가 `BASIC`으로 가입한 이메일과 동일한 Google 계정으로 로그인을 시도합니다.
2. 백엔드는 이 상황을 감지하고, 프론트엔드에 "이미 가입된 이메일입니다. Google 계정을 연결하시겠습니까?" 라는 특정 에러 응답을 보냅니다. (예: `ACCOUNT_NEEDS_LINKING` 에러 코드)
3. 프론트엔드는 이 응답을 받아 사용자에게 **계정 연결 동의 모달(Modal)**을 띄웁니다.x
4. 사용자가 '연결하기'를 누르면, **기존 계정의 비밀번호를 입력**하여 본인임을 최종 인증합니다.
5. 인증이 성공하면, 백엔드는 기존 `Member` 정보에 Google 로그인 방식을 추가하고, 최종적으로 로그인을 성공시킵니다.

---
